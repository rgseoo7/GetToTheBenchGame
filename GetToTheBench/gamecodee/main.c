#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
#include "gba.h"
#include "images/batman.h"
#include "images/bench.h"
#include "images/loseScreen.h"
#include "images/startScreen.h"
#include "images/endScreen.h"
#include "images/blackbox.h"
#include "images/squat.h"
#include "images/margotrobbie.h"
#include "images/gigachad.h"

/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  LOSE,
};

void delay (int n) {
  volatile int x = 0;
  for (int i = 0; i < n * 8000; i++) {
    x++;
  }
}

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  struct obstacles obstacles[15] = {
    {20, 110, 0, 0, 1},
    {40, 130, 0, 0, 3},
    {110, 190, 0, 0, 2},
    {40, 153, 0, 0, 3},
    {70, 80, 0, 0, 1},
    {121, 178, 0, 0, 2},
    {9, 84, 0, 0, 3},
    {58, 38, 0, 0, 1},
    {11, 80, 0, 0, 1},
    {50, 180, 0, 0, 2},
    {80, 40, 0, 0, 3},
    {120, 100, 0, 0, 1}, 
    {80, 200, 0, 0, 2},
    {80, 150 , 0, 0, 3},
    {120, 170, 0, 0, 1}
  };
  int object = sizeof(obstacles) / sizeof(obstacles[0]);
  for (int i = 0; i < object; i++) {
    if (obstacles[i].type == 1) {
      obstacles[i].height = SQUAT_HEIGHT;
      obstacles[i].width = SQUAT_WIDTH;
    } else if (obstacles[i].type == 2) {
      obstacles[i].height = MARGOTROBBIE_HEIGHT;
      obstacles[i].width = MARGOTROBBIE_WIDTH;
    } else if (obstacles[i].type == 3) {
      obstacles[i].height = GIGACHAD_HEIGHT;
      obstacles[i].width = GIGACHAD_WIDTH;
    }
  }
  struct batman bat = {40, 100, BATMAN_WIDTH, BATMAN_HEIGHT, 2, 2};
  struct bench goal = {70, 220, BENCH_WIDTH, BENCH_HEIGHT};

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;
  unsigned int count = 0;

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    switch (state) {
      case START:
        bat.row = 80;
        bat.col = 10;
        bat.height = BATMAN_HEIGHT;
        bat.width = BATMAN_WIDTH;
        bat.uvel = 2;
        bat.hvel = 2;

        waitForVBlank();
        if (count == 0) {
          drawFullScreenImageDMA(startScreen);
        }
        drawCenteredString(140, 120, 0, 0, "Get to the bench!", 0xFFFF);
        drawCenteredString(150, 120, 0, 0, "(Press START)", 0xFFFF);
        if (KEY_DOWN(BUTTON_START, currentButtons)) {
          state = PLAY;
          vBlankCounter = 0;
          count = 0;
          previousButtons = BUTTONS;
          break;
        }
        // state = ?
        previousButtons = BUTTONS;
        count++;
        break;
      case PLAY:
        if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {
          state = START;
          count = 0;
          previousButtons = BUTTONS;
          break;
        }
        int prevrow = bat.row;
        int prevcol = bat.col;
        if (KEY_DOWN(BUTTON_UP, currentButtons)) {
          bat.row -= bat.uvel;
          if (bat.row < 0) {
            bat.row = 0;
          }
        }
        if (KEY_DOWN(BUTTON_DOWN, currentButtons)) {
          bat.row += bat.uvel;
          if (bat.row > HEIGHT - bat.height) {
            bat.row = HEIGHT - bat.height;
          }
        }
        if (KEY_DOWN(BUTTON_LEFT, currentButtons)) {
          bat.col -= bat.hvel;
          if (bat.col < 0) {
            bat.col = 0;
          }
        }
        if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
          bat.col += bat.hvel;
          if (bat.col > WIDTH - bat.width) {
            bat.col = WIDTH - bat.width;
          }
        }
        if ((SCORE_COL <= bat.col + bat.width && SCORE_COL + 60 - 1 >= bat.col) && (SCORE_ROW <= bat.row + bat.height && SCORE_ROW + 10 - 1 >= bat.row)) {
          bat.col = prevcol;
          bat.row = prevrow;
        }
        int hit = 0;
        for (int i = 0; i < object; i++) {
          if ((obstacles[i].col + 1 <= bat.col + bat.width && obstacles[i].col + obstacles[i].width - 1 >= bat.col)
          && (obstacles[i].row + 1 <= bat.row + bat.height && obstacles[i].row + obstacles[i].height - 1 >= bat.row)) {
            waitForVBlank();
            delay(10);
            state = LOSE;
            count = 0;
            previousButtons = BUTTONS;
            hit = 1;
            break;
          }
        }
        if ((goal.col + 2 <= bat.col + bat.width && goal.col + goal.width - 2 >= bat.col)
          && (goal.row <= bat.row + bat.height && goal.row + goal.height - 2 >= bat.row)) {
            delay(10);
            state = WIN;
            count = 0;
            previousButtons = BUTTONS;
            hit = 1;
            break;
          }
        if (hit) {
          break;
        }
        char buffer[50];
        int time = vBlankCounter / 6;
        sprintf(buffer, "Score: %d", time);
        waitForVBlank();
        if (count == 0) {
          fillScreenDMA(BLACK);
          for (int i = 0; i < object; i++) {
            if (obstacles[i].type == 1) {
              drawImageDMA(obstacles[i].row, obstacles[i].col, obstacles[i].width, obstacles[i].height, squat);
            } else if (obstacles[i].type == 2) {
              drawImageDMA(obstacles[i].row, obstacles[i].col, obstacles[i].width, obstacles[i].height, margotrobbie);
            } else if (obstacles[i].type == 3) {
              drawImageDMA(obstacles[i].row, obstacles[i].col, obstacles[i].width, obstacles[i].height, gigachad);
            }
          }
          drawImageDMA(goal.row, goal.col, goal.width, goal.height, bench);
        } else {
          undrawImageDMA(prevrow, prevcol, bat.width, bat.height, blackbox);
          drawImageDMA(bat.row, bat.col, bat.width, bat.height, batman);
          undrawImageDMA(10, 180, 60, 10, blackbox);
          drawString(10, 180, buffer, 0xFFFF);
        }
        // state = ?
        count++;
        previousButtons = BUTTONS;
        break;
      case WIN:
        if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {
          state = START;
          count = 0;
          previousButtons = BUTTONS;
          break;
        }
        waitForVBlank();
        if (count == 0) {
          drawFullScreenImageDMA(endScreen);
        } else {
          sprintf(buffer, "Final Score: %d", time);
          drawString(70, 20, "You made it to the bench!", 0xFFFF);
          drawString(80, 130, buffer, 0xFFFF);
        }
        // state = ?
        count++;
        break;
      case LOSE:
        if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {
          state = START;
          count = 0;
          previousButtons = BUTTONS;
          break;
        }
        waitForVBlank();
        if (count == 0) {
          drawFullScreenImageDMA(loseScreen);
        } else {
          drawCenteredString(120, 120, 0, 0, "you got distracted...", 0xFFFF);
        }
        // state = ?
        count++;
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}